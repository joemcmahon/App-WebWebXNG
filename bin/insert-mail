#!/usr/bin/perl
use strict;

=head1 NAME

insert-mail - insert mail messages into a WebWebX whiteboard

=head1 SYNOPSIS

    insert-mail --whiteboard=config-file-path
                --page=PageWhereLinksShouldGo
                --prefix=PageNamePrefix
                --use-subject
                --debug
=head1 DESCRIPTION

C<insert-mail> provides a means for you to read mail messages and
insert them into a WebWebX whiteboard as individual pages. These pages
will be linked from an index page specified by you.

You can choose to have C<insert-mail> automatically generate a page
name for each message (using the C<--prefix> argument and a serial 
number initialized and maintained by C<insert-mail>, or you can have 
C<insert-mail> attempt to build a valid link name from the message 
subject (by specifying the C<--use-subject> argument).

If you specify C<--use-subject>, C<insert-mail> will automatically 
tag follow-ups onto the end of messages with the same subject.

C<insert-mail> reads the mail message to be processed from its 
standard input (it currently processes only one message at a time).
This makes it possible for you to use any standard means of routing
mail to the program (C<.forward> files, mail aliases, C<procmail>)
to have it insert the mail into the whiteboard.

Mail inserted by C<insert-mail> is written directly into the WebWebX
database for the selected whiteboard. This means that the 
whiteboard database files will need to be read/write accessible by 
both the webserver ID (nobody, wwwuser, etc.) and by the ID under which
C<insert-mail> is being run. 

It is simplest to do this by setting the gid bit on the database directory
and ensuring that the files written by C<insert-mail> and by WebWebX are 
group-readable and writable. Database modifications have been made in the
WebWEbX releases (2.1.4 and higher) which include C<insert-mail> to ensure
that group access is available.

=head1 BUGS

The database is written directly without reference to any of the WebWebX
access lists, making it possible for a page not otherwise modifiable to
be modified.

=cut

# Note this is a horribly large number of global variables, but the 
# current structure of WebWebX requires them. Sorry. New version
# will have methods for most of this stuff.

use vars qw( $ScriptName $LockDir $DataDir $FieldSeparator
             $OtherSeparator $LinkWord $LinkPattern $TickedOrNot
             $ReferencePattern $ImagePattern $AdminRec $MailPage
	     $AdminUser $AdminEmail $AggressiveLocking $SystemTitle
             $ScriptUrl $Today
             $CurrentUser $PageArchive
             %page
             $whiteboard $base_page $page_prefix $DEBUG $notify_users
             $use_subject
             @DebugMsgs
             $SerialCode
           );

#-----------------------------------------------------------------------------
# Change the following library name to reflect where PageArchive.pm and
# Storable.pm have been installed. If you are planning on running multiple
# webwebs, you should install them in a globally-accessible library.
#-----------------------------------------------------------------------------

BEGIN {
   push @INC,"/home/joe/public_html/webwebx/lib";
}

#-----------------------------------------------------------------------------
# Support libraries
#-----------------------------------------------------------------------------
use Storable;
use PageArchive;
use Sys::Hostname;
use Carp;
use Getopt::Long;


#-----------------------------------------------------------------------------
# You will need to install these CPAN modules.
#-----------------------------------------------------------------------------
use Mail::Internet;
use Mail::Header;
use Mail::Send;

# get_page
#
# Retrieves the page with the given title from the database.
# Creates a new, empty page (same title, revision 1) if no 
# page is found. Does NOT insert anything into the database!

sub get_page {

    my ($title) = @_;
    my (%page);

    my $revision = $PageArchive->max_version($title);
    note("Loading revision $revision of $title");
           
    # Check that the title is valid.
    
    $title =~ /^$LinkPattern$/ || croak "$title is an invalid name";
    
    # Return the page if it exists.
    
    %page = $PageArchive->get($title,$revision);
    
    if (%page) {
        my($z);
        foreach $z (keys %page) {
        }
    	return %page;
    }
    
    # Otherwise build a new one.
    note("Page $title does not exist, creating object for it"); 
    my @list = (
                 Owner        => $CurrentUser,
                 CreateUser   => $CurrentUser,
                 CreateDate   => $Today,
                 CreateHost   => hostname,
                 PageText     => "",
                 Revision     => 0,
                 Locked       => "",
                 Sticky       => "",
                 Archive      => "on",
                 Notification => "on",
                 LastMailed   => 0,
                 EditUser     => "",
                 EditHost     => "",
                 EditDate     => "",
                 TimeStamp    => time,
                 ReadACL      => "",
                 EditACL      => "",
                 ModifyACL    => "",
                 Links        => undef,
                 Title        => $title,
               );
    
    
    return @list;
}

# save_page
#
# Saves the supplied page at whatever revision it currently contains.

sub save_page {
    my ($pageref) = @_;
    $PageArchive->put($pageref->{Title},$pageref,$pageref->{Revision});
    note("Saving page as $pageref->{Title},$pageref->{Revision}");
    $PageArchive->getError()
	and croak "Could not put page: $PageArchive->getError()";
}

# update_links
#
# Removes any stale external links. Should be a no-op in most cases,
# unless the persons maintaining the base page decide to put an external
# link on it.

sub update_links {
    my $pageref = shift;
    # Remove any stale external links.
    
    my %links = split($OtherSeparator, $pageref->{Links});
    my (%newlinks,$searchfor,$link);

    foreach $link ( keys(%links) ) {
	
	$link =~ /^r($ReferencePattern)/ || next;
	$searchfor = $link;
	$searchfor =~ s/^r($ReferencePattern)/$1/;
	$pageref->{PageText} =~ /\[$searchfor\]/ 
	    && ($newlinks{$link} = $links{$link});
    }

    my @list = %newlinks;
    $pageref->{Links} = join($OtherSeparator, @list);
}

# send_notification
#
# sends mail to all of the people who asked for it when a page is updated.

sub send_notification {
    my $pageref= shift;
    
    my (@mail) = split($OtherSeparator, $pageref->{MailNotify});
    my ($name, $address, @addresses, $recp, $bcc);
    my $title = $pageref->{PageTitle};
    
    # Update the internal timestamp (Note that since this subroutine
    # is only called after POST requests, the DBM file is automatically
    # locked so the save operation is safe).
    
    $pageref->{LastMailed} = time;
    note("Saving new timestamp");
    save_page($pageref);
    
    # Assemble the existing addresses into the list.
    note("Building list of users");
    
    my %emails = $PageArchive->get($MailPage,0);
    
    foreach $name (@mail) {
	
#   ($name eq $CurrentUser) && next;
	($address = $emails{$name}) || next;
	
	push(@addresses, $address);
    }
    
    # Use the first address as the recipient and put the others on
    # the Bcc list (blind carbon copy).
    
    $recp = pop(@addresses);
    $bcc = join(',', @addresses);
    
    $recp || return;
    
    my $mail = new Mail::Send;
    $mail->to($recp);
    $mail->from("insert_mail" . ($SystemTitle ? " for $SystemTitle" : ""));
    $mail->bcc($bcc) if $bcc;
    $mail->subject("$pageref->{Title} has changed");
    
    my $fh = $mail -> open;
    
    $SystemTitle
	&& print $fh "\"$SystemTitle\"\n\n";
    
    print $fh "This is an automatic message sent by WebWeb. The page\n";
    print $fh "\"$title\" has been changed by \"$CurrentUser\". Follow\n";
    print $fh "the URL below to see the page:\n\n";
    print $fh "$ScriptUrl?ViewPage=$title\n\n";
    print $fh "- WebWeb\n\n";
    
    $fh->close;
}

# --------------------------
# Administration Subroutines
# --------------------------

# load_admin_info
#
# Load the admin info. We are loading only the stuff we can use.

sub load_admin_info {
    
    # Get the record and grab the system properties from it.
    my %rec = $PageArchive->get($AdminRec,0);
    if (%rec) {

	$AdminUser          = $rec{AdminUser};
	$AdminEmail         = $rec{AdminEmail};
        $AggressiveLocking  = $rec{AggressiveLocking};
        $SystemTitle        = $rec{SystemTitle};
        note("admin settings loaded OK");
    } 
    else {
        croak "Could not load administrator data, exiting: ",
              $PageArchive->getError();
    }
}

# request_lock
#
# Creates a lock directory to indicate exclusive access to the DBM
# files. Sleeps for up to 10 minutes if the directory exists, after
# which time it will abort.

sub request_lock {

    my $count = 0;
    note("Attempting to lock $LockDir");
    
    while (mkdir($LockDir, 0555) == 0) {
	
	# Check if the directory exists, or print an error message if the
	# directory could not be created for any other reason.
	
	$! == 17 || die "Can't create lock $LockDir: $!";
	
	# Check that we haven't timed out.
	
	$count++ < 30 || &FatalError("Timed out waiting for lock $LockDir");
	
	# Wait one second before trying again.
	
	sleep(20);
    }
    note("Locking succeeeded after $count tries");
}

# release_lock
#
# Frees exclusive access to the DBM files by removing the lock
# directory.

sub release_lock {

    rmdir($LockDir);
    note("Lock released");
}

# do_unlock (page)
#
# Unlocks the page if possible.

sub do_unlock {
        my ($target) = shift;
        # See if the page is locked.
        my ($unlocked, $locker) = $PageArchive->is_unlocked($target);
        return if $unlocked;

        # Try to unlock it.
        $PageArchive->unlock($target);
        my ($unlocked, $discard_this) = $PageArchive->is_unlocked($target);
        croak "Internal error: unlock of $target failed. "
            unless $unlocked;
}

#----------------------
# Internal utility routines.
#----------------------

sub note {
   my $now = scalar localtime(time);
   my $space = " " x (1+length($now));
   local $_;
   push @DebugMsgs,"$now: " . shift(@_) ."\n"; 
   foreach (@_){ push @DebugMsgs,"$space $_\n";}
}

sub usage {
    print join @_,"\n" if @_;
    print <<EOF;
    Usage: insert-mail --whiteboard=config-file 
                       --prefix=PageNamePrefix
                       --page=PageName
EOF
    exit(1);
}

sub config_internals {
    # Defaults for use when the system is being configured for the
    # first time.

    $ScriptName = "insert-mail";

    # Work out all of the other directory names.
    $LockDir = "$DataDir/$ScriptName" . ".lck";

    # Internal field separator characters.
    $FieldSeparator = "\263";
    $OtherSeparator = "\264";

    # LinkPattern is the regular expression which matches page titles.
    $LinkWord = "[A-Z][a-z]+";
    $LinkPattern = "($LinkWord){2,}";
    $TickedOrNot = "``$LinkPattern|$LinkPattern";

    # ReferencePattern is a regular expression which matches external 
    # references.
    $ReferencePattern = "[A-Z,a-z,0-9]+";

    # ImagePattern is a regexp which matched all image URLs (the search is
    # case insensitive).
    $ImagePattern = '\.gif$|\.jpg$|\.jpeg$';

    # Name of the admin record in the DBM hash
    $AdminRec = "admin000";

    # Name of the mail directory page.
    $MailPage = "MAIL000";

    # String that delimits the serial number on the base page.
    $SerialCode = "Sequence number (do not remove or modify)";

}

sub accessible {
    my $title = shift;
    
    # Check the user is allowed to access the page.
    
    if ($AggressiveLocking) {
        note("checking locks");
        my ($unlocked, $locker) = $PageArchive->is_unlocked($title);
        if ($unlocked) {
            note("not locked, locking");
            my $CurrentHost = hostname;
            my ($available,$locked_by) = 
                $PageArchive->lock($title,$CurrentUser,$CurrentHost);	
                croak "This page is now being edited.<p>" .
                        "It is in use by $locker" 
                unless $available;
        }
        elsif ($locker !~ /^$CurrentUser/) {
            croak "This page is still being edited.<p>" .
                        "It is in use by $locker" 
        }
    }
}

sub number_to_link {
   my @numbers = split //,$_[0];
   my @words = qw(Zero One Two Three Four Five Six Seven Eight Nine);
   return join("",(map { @words[$_] } @numbers));
}
   
# -----------------
# Main Program Body
# -----------------

$| = 1;

usage() unless @ARGV;

GetOptions( "whiteboard=s" => \$whiteboard,
             "page=s"       => \$base_page,
             "prefix=s"     => \$page_prefix,
             "debug"        => \$DEBUG,
             "notify"       => \$notify_users,
             "use-subject"  => \$use_subject,
           );

# Validate parameters.
# If --use-subject is off, --prefix is required.
# --whiteboard and --page are always required.

usage("--whiteboard, --prefix, and --page parameters are required")
    unless defined $whiteboard && defined $base_page && defined $page_prefix;

# Load whiteboard configuration, or die.

eval {require "$whiteboard"};
$@ and croak "Can't load configuration '$whiteboard': $@";

# Connect to the database, or die.

$PageArchive = new PageArchive($DataDir);
my $errstate = $PageArchive->getError();
croak "Can't open database: $errstate" if $errstate;

# Finish internal initialization.

@DebugMsgs = ();
config_internals;
load_admin_info;
$CurrentUser = "insert_mail";
request_lock;

# Parse the incoming mail; extract from, subject, received, and text.

my $message = new Mail::Internet(\*STDIN);
my @body    = @{$message->body};

unless (@body) {
    note "message has no body. Skipped.";
    exit(0);
}

my $header  = $message->head;
$header->fold;

my $subject = $header->get("Subject");  chomp $subject;
my $from    = $header->get("From");     chomp $from;
my $recd    = $header->get("Received"); chomp $recd;

my @new_lines = ( "----",
                  " Subject:   $subject",
                  " From:      $from",
                  " Received:  $recd",
                  " ",
                );

foreach my $line (@body) {
    chomp $line;
    push @new_lines, " " . $line;
}

# Get base page and lock it. We wil get an empty page if it doesn't exist.
# Do not check for "same user" - it *will* be the same user if
# multiple mail messages come in!

my %base_page = get_page($base_page);
my ($available,$locked_by) = 
    $PageArchive->lock($base_page,$CurrentUser,hostname);
croak "base page $base_page locked, cannot access: $locked_by"
    unless $available;

# Decide if we need to use the subject as supplied, or if we should
# build a title out of the prefix and serial number. 

my $mail_page;

# Use the mail subject. Clean off "Re: " so subject matches.
if ($use_subject) {
    $mail_page = $header->get("Subject");
    $mail_page =~ s/Re: //ig;

    # Coerce it into a proper link name.
    my @words = split(/\s+/,$mail_page);
    @words = map {ucfirst lc} @words;
    $mail_page = join("",@words);
    $mail_page =~ tr/A-Za-z//dc;

    # If still not a proper link, add the prefix.
    # Null names will fall into the serial number code.
    if ($mail_page and $mail_page !~ /$LinkPattern/) {
       $mail_page = $page_prefix . $mail_page;
    }
}

# Create a name from the prefix and serial number.
# We're forced to do this if the sender used something we
# can't coerce into a proper page title (with --use-subject on).

unless ($mail_page) {
    my @lines = split /\n/,$base_page{PageText};
    my $serial_number = "";

    # Page had no serial number (probably blank). Put one on the bottom.
    my $meta = quotemeta($SerialCode);
    unless (grep /$meta: \d+/,@lines) {
        push @lines, (" ", "----","$SerialCode: 0000","----"." ");
    }

    # Find the line where the serial number is an pull it out.
    # We save the line number so we can modify it in place.

    my $serial_index = 0;
    foreach my $line (@lines) {
        last if ($serial_number) = ($line =~ /$meta: (\d+)/);
        $serial_index++;
    }

    # Replace the serial number.
    $serial_number++;
    $lines[$serial_index] = "$SerialCode: $serial_number";

    $base_page{PageText} = join "\n",@lines;

    # create new page name.
    $mail_page = $page_prefix . number_to_link($serial_number);
}

# Load page. Will be empty if new. 

my %mail_page = get_page($mail_page);

# Lock it. Die if we can't.
($available,$locked_by) = 
    $PageArchive->lock($mail_page,$CurrentUser,hostname);
croak "mail page $mail_page locked, cannot access: $locked_by"
    unless $available;

# Tack on the new mail. Appends if there was already some there.
# Stick on a "Back to base page" link if the page is empty.

$mail_page{PageText}  = "Back to $base_page\n" unless $mail_page{PageText};
$mail_page{PageText} .= join("\n",@new_lines);
$mail_page{PageText} .= "\n" unless $mail_page{PageText} =~ /\n$/;

# store the new page

$mail_page{Revision}++;
save_page(\%mail_page);

# insert new entry on base page. Skip if already there.

$base_page{PageText} = "# * $mail_page\n$base_page{PageText}"
   unless $base_page{PageText} =~ /# \* $mail_page/;

# Up the revision number, clean it up, and save it.

$base_page{Revision}++;
update_links(\%base_page);
save_page(\%base_page);

# Tell the proper people if desired.

send_notification(\%base_page) if $notify_users;

# Let go of all of it.
$PageArchive->unlock($mail_page);
$PageArchive->unlock($base_page);

# exit
release_lock;
if (scalar @DebugMsgs && $DEBUG) {
    foreach (@DebugMsgs) {print;}
}
